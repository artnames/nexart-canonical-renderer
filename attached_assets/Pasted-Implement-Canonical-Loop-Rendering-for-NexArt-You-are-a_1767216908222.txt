Implement Canonical Loop Rendering for NexArt

You are a senior backend graphics engineer working on the NexArt Canonical Renderer Node.

This node is the authoritative execution environment for NexArt Code Mode and MUST use @nexart/codemode-sdk as the single source of truth.

Preview rendering already works in the browser.
Your task is to add true canonical LOOP rendering on the server.

‚∏ª

üîí Context (Non-Negotiable)
	‚Ä¢	The renderer is a Node.js service (Express)
	‚Ä¢	Deployed to Railway
	‚Ä¢	Uses canvas (node-canvas)
	‚Ä¢	Uses @nexart/codemode-sdk
	‚Ä¢	Protocol canvas size is LOCKED to 1950√ó2400
	‚Ä¢	Determinism is mandatory

Loop mode is currently incorrectly falling back to static PNG.
This must be fixed.

‚∏ª

üéØ Goal

Implement true canonical loop rendering so that:
	‚Ä¢	execution.mode === "loop"
	‚Ä¢	totalFrames > 1
	‚Ä¢	draw() is executed frame-by-frame
	‚Ä¢	Frames are captured deterministically
	‚Ä¢	Output is a real animation (MP4 or WebM)
	‚Ä¢	The renderer explicitly declares loop output

No fallbacks. No silent downgrade.

‚∏ª

üß† Required Architecture

1. Execution

Use @nexart/codemode-sdk loop execution semantics:
	‚Ä¢	Initialize runtime once
	‚Ä¢	Call setup() exactly once
	‚Ä¢	Call draw() N times
	‚Ä¢	Increment frameCount correctly
	‚Ä¢	Respect seed and VAR[]

Do NOT re-implement p5 logic manually.

‚∏ª

2. Frame Capture

For each frame:
	‚Ä¢	Render into the same canvas
	‚Ä¢	Capture raw frame buffer
	‚Ä¢	Store frames sequentially (PNG buffers in temp dir or memory)

‚∏ª

3. Encoding (Required)

After rendering all frames:
	‚Ä¢	Encode frames into MP4 or WebM
	‚Ä¢	Use ffmpeg (already allowed)
	‚Ä¢	Fixed frame rate (e.g. 30fps)
	‚Ä¢	Deterministic ordering
	‚Ä¢	No resizing, cropping, or filtering

‚∏ª

4. Hashing (Critical)

Compute:
	‚Ä¢	animationHash ‚Üí SHA-256 of final video bytes
	‚Ä¢	posterHash ‚Üí SHA-256 of frame 0 PNG
	‚Ä¢	snapshotHash ‚Üí unchanged

These hashes are protocol-level guarantees.

‚∏ª

5. Response Contract (MANDATORY)

For loop mode, the renderer must return JSON, not headers:

{
  "type": "animation",
  "mime": "video/mp4",
  "animationBase64": "...",
  "animationHash": "...",
  "posterBase64": "...",
  "posterHash": "...",
  "frames": 120,
  "width": 1950,
  "height": 2400
}

Static mode may continue returning PNG.

‚∏ª

üö´ Forbidden Shortcuts

DO NOT:
	‚Ä¢	Return PNG when loop was requested
	‚Ä¢	Fake animation by duplicating one frame
	‚Ä¢	Use browser APIs
	‚Ä¢	Use preview canvas
	‚Ä¢	Encode client-side frames
	‚Ä¢	Skip hashing
	‚Ä¢	Infer loop from draw() presence

If loop rendering fails ‚Üí throw error.

‚∏ª

üß™ Validation Requirements

Hard-fail if:
	‚Ä¢	Output dimensions ‚â† 1950√ó2400
	‚Ä¢	totalFrames < 2
	‚Ä¢	Video bytes < reasonable size
	‚Ä¢	animationHash missing
	‚Ä¢	isLoopMode ambiguity exists

‚∏ª

üìÇ Files You Will Modify
	‚Ä¢	render-loop.js ‚Üê primary work
	‚Ä¢	Possibly server.js
	‚Ä¢	Possibly validation.js

Do NOT change the protocol surface or snapshot format.

‚∏ª

‚úÖ Definition of Done
	‚Ä¢	Loop mint no longer falls back to static
	‚Ä¢	ByX logs show:

isLoopMode: true
animationHash: <present>


	‚Ä¢	IPFS receives a video
	‚Ä¢	Static and loop paths are clearly separated
	‚Ä¢	Determinism verified (same input ‚Üí same hash)

‚∏ª

‚ö†Ô∏è Philosophy (Important)

This node is not a convenience renderer.
It is a protocol authority.

If something cannot be rendered canonically ‚Äî it must fail.

‚∏ª

Start by implementing true loop execution and encoding.

Do not simplify.
Do not guess.
Do not bypass the SDK.
